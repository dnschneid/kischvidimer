# SPDX-FileCopyrightText: (C) 2025 Rivos Inc.
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
# SPDX-License-Identifier: Apache-2.0

# This module generates a netlist of a design, attempting to match KiCad's
# behaviors as closely as possible. There are, however a bunch of edge cases
# around implicitly-named nets that are not yet perfectly duplicated here:
#  * A net that is connected between two blocks and not named at the higher
#    level should not simply pick the lexicographically-minimum name. There is
#    some other criteria that KiCad uses that needs to be investigated.
#    See connection_graph.cpp; there's a preference for hierarchical outputs but
#    there's more to it than that.

import re
from collections import namedtuple

from . import sexp
from .kicad_common import HasUUID, unit_to_alpha
from .kicad_sym import SymbolBody, SymbolDef


class NetBus:
  CAT_NETTIE = 0
  CAT_POWER = 1
  CAT_LABEL = 2
  CAT_SYMPIN = 3
  CAT_SYMPIN_UNNAMED = 4
  CAT_SYMPIN_PWR = 5
  CAT_SHEETPIN = 6

  CATS_SYMPIN = (CAT_SYMPIN, CAT_SYMPIN_UNNAMED, CAT_SYMPIN_PWR)

  NAME_ENTRY = namedtuple("NameEntry", ["category", "depth", "key", "name"])
  PIN_NAME = namedtuple("PinInfo", ["ref", "name", "number", "is_unique"])

  @staticmethod
  def new(is_bus):
    return Bus() if is_bus else Net()

  def __init__(self):
    self._mergedinto = None
    self._names = set()
    self._ncs = set()
    self._nodes = []
    self._has_wires = False

  def is_floating_sympin(self):
    # FIXME: replace(?) with an InstCoord unique node counter
    while self._mergedinto is not None:
      self = self._mergedinto
    if self._has_wires or self._ncs:
      return False
    has_sympin = False
    for n in self._names:
      if (
        n[0] not in NetBus.CATS_SYMPIN or has_sympin and has_sympin != n[-1].ref
      ):
        return False
      else:
        has_sympin = n[-1].ref
    return bool(has_sympin)

  def merge_into(self, item):
    assert self._mergedinto is None
    while item._mergedinto is not None:
      item = item._mergedinto
    if item is not self:
      item._names.update(self._names)
      item._ncs.update(self._ncs)
      item._nodes.extend(self._nodes)
      item._has_wires = item._has_wires or self._has_wires
      self._mergedinto = item
    return item

  @property
  def unmerged(self):
    return self._mergedinto is None

  def add_name(self, name, category):
    # name is either a string or a PIN_NAME tuple
    assert self.unmerged
    # Reprioritize names that are autogenerated by symbol pins
    if category == NetBus.CAT_SYMPIN:
      if name.ref.startswith("#"):
        category = NetBus.CAT_SYMPIN_PWR
      elif (name.name or "~") == "~":
        category = NetBus.CAT_SYMPIN_UNNAMED
    depth = name.count("/")
    key = (
      name.upper()
      if isinstance(name, str)
      else tuple(n.upper() for n in name if isinstance(n, str))
    )
    self._names.add(
      NetBus.NAME_ENTRY(category=category, depth=depth, key=key, name=name)
    )

  def change_name_category(self, name, fromcat, tocat):
    """Used to drop the priority of labels that tap off of unnamed buses"""
    assert self.unmerged
    assert fromcat == NetBus.CAT_LABEL
    for n in self._names:
      if n.category == fromcat and n.name == name:
        self._names.remove(n)
        self.add_name(name, tocat)
        break

  def name(self):
    while self._mergedinto:
      self = self._mergedinto
    if not self._names:
      return None
    name = min(self._names)
    if name.category in NetBus.CATS_SYMPIN:
      pre = (
        "Net"
        if sum(1 for n in self._names if n.category in NetBus.CATS_SYMPIN) > 1
        else "unconnected"
      )
      pinname = list(name.name)
      if pinname[3] and (pinname[1] or "~") != "~":  # is_unique
        del pinname[-1:]  # no pin number when name is unique
      else:
        pinname[2] = f"Pad{pinname[2]}"
      pinname = "-".join(p for p in pinname[:-1] if p and p != "~")
      return f"{pre}-({pinname})"
    return name[-1]

  def nodes(self, svg):
    while self._mergedinto:
      self = self._mergedinto
    nodes = set()
    for instance, node, alt_id in self._nodes:
      nodes.add(
        (instance and instance.instance, alt_id if alt_id else svg.getuid(node))
      )
    return nodes

  def instances(self, exclude_context=None):
    while self._mergedinto:
      self = self._mergedinto
    exclude_instance = exclude_context and Instance(exclude_context)
    return {i.instance for i, _, _ in self._nodes if i != exclude_instance}

  def add_node(self, instance, node, alt_id=None):
    self._nodes.append((instance, node, alt_id))

  def add_nc(self, instance):
    self._ncs.add(instance)

  def add_wire(self, instance):
    self._has_wires = True

  def __eq__(self, other):
    while other._mergedinto is not None:
      other = other._mergedinto
    while self._mergedinto is not None:
      self = self._mergedinto
    return self is other


class Net(NetBus):
  FMT_SHORT = 0  # net: U1.1 U2.1
  FMT_NAMES = 1  # net: U1.1(VDD) U2.1(VOUT)
  FMT_TELESIS = 2  # 'NET';,\n\tU1.1,\n\tU2.1
  REMOVE_UNIT_RE = re.compile("[A-Z]+$")
  TEL_QUOTE_RE = re.compile("[^a-zA-Z0-9_/]")

  def _get_pins(self):
    return {
      (Net.REMOVE_UNIT_RE.sub("", n[0]),) + n[1:-1]
      for c, _, _, n in self._names
      if c in NetBus.CATS_SYMPIN
    }

  def fmt(self, fmt):
    name = self.name()
    if name is None:
      return ""
    pins = sorted(self._get_pins(), key=lambda n: (n[0], n[2], n[1]))
    if not pins:
      return ""
    # Drop explicitly NC'd nets
    if len(pins) == 1 and self._ncs:
      return ""
    if fmt == Net.FMT_SHORT:
      nodes = " ".join(f"{r}.{num}" for r, _, num in pins if r[0] != "#")
      return f"{name}: {nodes}"
    if fmt == Net.FMT_NAMES:
      nodes = " ".join(
        f"{r}.{num}" + f"({name})" * ((name or "~") not in (num, "~"))
        for r, name, num in pins
        if r[0] != "#"
      )
      return f"{name}: {nodes}"
    if fmt == Net.FMT_TELESIS:
      if Net.TEL_QUOTE_RE.search(name):
        name = f"'{name}'"
      nodes = ",\n\t".join(f"{r}.{num}" for r, _, num in pins if r[0] != "#")
      return f"{name.upper()};,\n\t{nodes}"
    return ""


class Bus(NetBus):
  def __init__(self):
    self.members = ReplaceableDict()
    self._sheetpins = []
    self._subsheet_buses = []
    super().__init__()

  def add_member(self, member, net):
    assert self.unmerged
    assert isinstance(net, Net)
    assert net.unmerged
    net.add_node(None, self)
    return self.members.setrep(member, net)

  def add_sheetpin(self, subsheet_bus, local_labels):
    assert self.unmerged
    self._subsheet_buses.append(subsheet_bus)
    self._sheetpins.append(local_labels)
    return self

  def merge_into(self, item):
    assert isinstance(item, Bus)
    assert self.unmerged
    while item._mergedinto is not None:
      item = item._mergedinto
    if item is self:
      return item
    for member in self.members:
      item.add_member(member, self.members.getrep(member))
    item._sheetpins.extend(self._sheetpins)
    item._subsheet_buses.extend(self._subsheet_buses)
    return super().merge_into(item)

  def all_members(self):
    while self._mergedinto is not None:
      self = self._mergedinto
    assert not self._sheetpins  # invalid until sheetpins have been resolved
    return {n.name() for n in self.nets}

  def gen_local_labels(self):
    while self._mergedinto is not None:
      self = self._mergedinto
    sheetpins = self._sheetpins
    self._sheetpins = []
    # Generate local labels only if there was no label
    if not sheetpins or self.name() is not None:
      return []
    assert not self.members
    # add the intersection of all the connected sheet pin members
    members_il = None
    for i, local_labels in enumerate(sheetpins):
      members_il = {
        member: (il, netname)
        for il, member, netname in local_labels
        if not i or member in members_il
      }
    labels = [
      (il, netname, self.add_member(member, Net()))
      for member, (il, netname) in members_il.items()
    ]
    return labels

  def resolve_sheetpins(self):
    while self._mergedinto is not None:
      self = self._mergedinto
    assert not self._sheetpins  # gen_local_labels should have been done first
    subsheet_buses = self._subsheet_buses  # pre-clear so we can merge
    self._subsheet_buses = []
    for subsheet_bus in subsheet_buses:
      while subsheet_bus._mergedinto is not None:
        subsheet_bus = subsheet_bus._mergedinto
      # Only merge the whole bus if the members are the exact same
      if subsheet_bus.members.keys() == self.members.keys():
        subsheet_bus.merge_into(self)
        continue
      # Otherwise, merge the members that overlap
      for member in self.members.keys() & subsheet_bus.members.keys():
        subsheet_bus.add_member(member, self.members.getrep(member))
      # Add references to superset buses
      if self.members.keys() > subsheet_bus.members.keys():
        subsheet_bus.add_node(None, self)
      elif self.members.keys() < subsheet_bus.members.keys():
        self.add_node(None, subsheet_bus)
    # Give it a name if there isn't one, although it doesn't mean much
    if self.name() is None:
      for sb in subsheet_buses:
        self.add_name(sb.name(), NetBus.CAT_SHEETPIN)


class ReplaceableDict(dict):
  def getrep(self, key, setdefault=None):
    item = self.get(key)
    if item is None:
      if setdefault is None:
        raise KeyError(key)
      self[key] = setdefault
      return setdefault
    while item._mergedinto is not None:
      self[key] = item = item._mergedinto
    return item

  def setrep(self, key, item):
    assert item.unmerged
    curitem = self.getrep(key, item)
    self[key] = curitem.merge_into(item)
    return item


class Instance(namedtuple("Instance", ["instance"])):
  def __new__(cls, context, include_uuid=False):
    if isinstance(context, Instance):
      return super().__new__(cls, instance=context.instance)
    path = None
    sheet = None
    for c in reversed(context):
      if c.type == "path":
        path = c
      elif c.type == "sheet":
        sheet = c
    instance = path.uuid(sheet)
    if include_uuid:
      # Include the last context item's UUID in the path
      for c in reversed(context):
        if isinstance(c, HasUUID):
          instance = f"{instance.rstrip('/')}/{c.uuid(True)}"
          break
    return super().__new__(cls, instance=instance)


class InstCoord(namedtuple("InstCoord", ["instance", "x", "y", "is_bus"])):
  def __new__(cls, context, item, is_bus):
    inst = Instance(context)
    # FIXME: probably no diffs
    x, y = item if isinstance(item, tuple) else item.pts([])[0]
    return super().__new__(cls, instance=inst, x=x, y=y, is_bus=is_bus)


class InstLabel(namedtuple("InstLabel", ["instance", "text"])):
  def __new__(cls, context, item, is_global, include_uuid=False):
    inst = None if is_global else Instance(context, include_uuid=include_uuid)
    # FIXME: probably no diffs
    text = item if isinstance(item, str) else item.net([], context)
    return super().__new__(cls, instance=inst, text=text)


class NetObj(namedtuple("NetObj", ["xys", "is_bus"])):
  """Objects used for collision detection"""

  UNKNOWN = -1

  def __new__(cls, obj, is_bus=UNKNOWN):
    return super().__new__(cls, xys=obj.pts([]), is_bus=is_bus)

  def test(self, other):
    if len(other.xys) > len(self.xys):
      return other.test(self)
    if self.is_bus != other.is_bus and NetObj.UNKNOWN not in (
      self.is_bus,
      other.is_bus,
    ):
      return False
    p = self.xys
    # For line-line detections, only do endpoint comparisons
    if len(other.xys) > 1:
      return any(xy in p for xy in other.xys)
    # Line-point detection
    xy = other.xys[0]
    # Box test
    if not (p[0][0] <= xy[0] <= p[1][0] or p[1][0] <= xy[0] <= p[0][0]):
      return False
    if not (p[0][1] <= xy[1] <= p[1][1] or p[1][1] <= xy[1] <= p[0][1]):
      return False
    # Collinear test
    return (p[1][0] - p[0][0]) * (xy[1] - p[0][1]) == (xy[0] - p[0][0]) * (
      p[1][1] - p[0][1]
    )


class Netlister:
  def __init__(self):
    self._by_instcoord = ReplaceableDict()
    self._by_instlabel = ReplaceableDict()
    self._unresolved_buses = []
    self._nodes_by_inst = {}
    self._wires_by_inst = {}
    self._instcoord_count = {}  # connection count by coordinate
    self.netprefix = "/"  # updated by callers to set the local net name prefix

  def context(self):
    s = sexp.SExp.init(
      [
        sexp.Atom("~netlister"),
      ]
    )
    s.netlister = self
    return (s,)

  @staticmethod
  def n(context):
    """Finds the first netlister instance in the context
    Returns a dummy class with get_net and get_node_count if not found.
    """
    if isinstance(context, Netlister):
      return context
    for c in context:
      if hasattr(c, "netlister"):
        return c.netlister

    class Dummy:
      def context(self):
        return ()

      def get_net(self, context, xy, is_bus=False):
        return NetBus.new(is_bus)

      def get_node_count(self, context, xy, is_bus=False):
        return -1

      def generate_netmap(self, svg):
        return Netlister().generate_netmap(svg)

    return Dummy()

  def get_net(self, context, xy, is_bus=False):
    """Returns a NetBus for the given coordinate+is_bus"""
    assert not self._unresolved_buses
    ic = InstCoord(context, xy, is_bus)
    return self._by_instcoord.getrep(ic)

  def get_node_count(self, context, xy, is_bus=False):
    """Returns the node count at a point+is_bus."""
    ic = InstCoord(context, xy, is_bus)
    return self._instcoord_count[ic]

  def _add_node(self, ic, item):
    if ic in self._by_instcoord:
      self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
      netbus = self._by_instcoord.getrep(ic)
      netbus.add_node(ic.instance, item)
      return netbus
    wires = self._wires_by_inst.setdefault(ic.instance, [])
    node = NetObj(item, ic.is_bus)
    netbus = None
    for wire in wires:
      if wire.test(node):
        self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
        netbus = self._by_instcoord.getrep(
          InstCoord(ic.instance, wire.xys[0], ic.is_bus)
        )
        break
    else:
      netbus = NetBus.new(ic.is_bus)
    self._by_instcoord[ic] = netbus
    self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
    netbus.add_node(ic.instance, item)
    return netbus

  def _add_wire(self, inst, wire):
    self._wires_by_inst.setdefault(inst, []).append(wire)
    nodes = self._nodes_by_inst.setdefault(inst, [])
    netbus = None
    for i in range(len(nodes) - 1, -1, -1):
      node = nodes[i]
      if wire.test(node):
        ic = InstCoord(inst, node.xys[0], node.is_bus)
        self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
        if netbus is None:
          netbus = self._by_instcoord.getrep(ic)
        else:
          netbus = self._by_instcoord.setrep(ic, netbus)
        del nodes[i : i + 1]
    return netbus

  def add_label(self, context, label):
    bus = label.bus([], context)
    is_global = label.type == "global_label"
    ic = InstCoord(context, label, bool(bus))
    il = InstLabel(context, label, is_global)
    netbus = self._add_node(ic, label)
    netbus = self._by_instlabel.setrep(il, netbus)
    netbus.add_name(
      label[0] if is_global else f"{self.netprefix.rstrip('/')}/{label[0]}",
      category=NetBus.CAT_LABEL,
    )
    if not bus:
      return netbus
    for _prefix, member, netname in label.expand_bus([], context):
      il = InstLabel(context, netname, is_global)
      busnet = self._by_instlabel.getrep(il, Net())
      busnet = netbus.add_member(member, busnet)
      busnet.add_name(
        member if is_global else f"{self.netprefix.rstrip('/')}/{netname}",
        category=NetBus.CAT_LABEL,
      )
    return netbus

  def add_sheetpin(self, context, pin):
    bus = pin.bus([], context)
    ic = InstCoord(context, pin, bool(bus))
    # Sheetpins do not cause wire breaks, so need to use _add_node
    netbus = self._add_node(ic, pin)
    # Sheet pins don't generate a netname; they just inherit the local name
    # connect net to subsheet via _by_instlabel
    il = InstLabel(context, pin, False, include_uuid=True)
    if bus:
      # don't immediately connect buses to subsheet
      self._unresolved_buses.append(netbus)
      subsheet_bus = self._by_instlabel.getrep(il, Bus())
      local_labels = [
        (
          InstLabel(context, netname, False),
          member,
          f"{self.netprefix.rstrip('/')}/{netname}",
        )
        for _, member, netname in pin.expand_bus([], context)
      ]
      return netbus.add_sheetpin(subsheet_bus, local_labels)
    return self._by_instlabel.setrep(il, netbus)

  def add_sympin(self, context, pin):
    ref = None
    show_unit = None
    unit = ""
    symbol_def = None
    is_unique = False
    symuuid = None
    pins = None
    for c in reversed(context):
      if isinstance(c, SymbolBody):
        unit = unit_to_alpha(c.unit)
      elif isinstance(c, SymbolDef):
        symbol_def = c
      elif hasattr(c, "refdes"):
        symuuid = c.uuid(generate=True)
        ref = c.refdes([], context)
        show_unit = c.show_unit([], context)
        variant = c.variant([], context)
        pins = symbol_def.get_pins([], context, variant=variant)
        break
    name, number = pin.name_num([], context)
    pintype = pin.get_type_style([], context)[0]
    is_unique = len(pins[name]) == 1
    # FIXME: alternates can cause electrical type of hidden pin to be power
    # input (or not). does that still make it a power net?
    is_pwr = pin.hide([]) and pintype == "power_in"
    is_nc = pintype == "no_connect"
    # If name is not empty, include unit letter if there's more than one
    if ref and show_unit and name and name != "~":
      ref += unit
    pinnet = (
      name
      if is_pwr
      else NetBus.PIN_NAME(
        ref=ref, name=name, number=number, is_unique=is_unique
      )
    )
    netbus = Net()
    # Pins cause wire breaks in the editor, so can do point checks
    ic = InstCoord(context, pin.pts([], context)[0], False)
    self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
    if is_pwr:
      il = InstLabel(context, pinnet, True)
      netbus = self._by_instlabel.getrep(il, netbus)
    elif is_nc:
      netbus.add_nc(ic.instance)
    netbus = self._by_instcoord.setrep(ic, netbus)
    netbus.add_node(ic.instance, self, (symuuid, number))
    netbus.add_name(
      pinnet, category=NetBus.CAT_POWER if is_pwr else NetBus.CAT_SYMPIN
    )
    return netbus

  def add_nc(self, context, nc):
    # NCs do not contribute any potential net name, so just return the net
    # We also don't know if they're a bus, so return both.
    # Also, NCs do not split lines, so need to use the more complex detection.
    nbs = []
    for is_bus in False, True:
      ic = InstCoord(context, nc, is_bus)
      netbus = self._add_node(ic, nc)
      netbus.add_nc(ic.instance)
      nbs.append(netbus)
    return nbs

  def add_wire(self, context, wire):
    is_bus = wire.type == "bus"
    ic = Instance(context)
    netbus = self._add_wire(ic, NetObj(wire, is_bus))
    for xy in wire.pts([]):
      ic = InstCoord(context, xy, is_bus)
      self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
      if netbus is None:
        netbus = self._by_instcoord.getrep(ic, NetBus.new(is_bus))
      else:
        netbus = self._by_instcoord.setrep(ic, netbus)
    netbus.add_wire(ic.instance)
    netbus.add_node(ic.instance, wire)
    return netbus

  def add_busentry(self, context, busentry):
    nbs = []
    pts = busentry.pts([])
    ic = None
    for is_bus in False, True:
      for pt in pts:
        ic = InstCoord(context, pt, is_bus)
        self._instcoord_count[ic] = self._instcoord_count.get(ic, 0) + 1
        netbus = self._by_instcoord.getrep(ic, NetBus.new(is_bus))
        netbus.add_node(ic.instance, busentry)
        nbs.append(netbus)
    return nbs

  def add_junction(self, context, junction):
    # junctions shouldn't be able to modify the netlist, since associated wires
    # always terminate at the same coordinate.
    # Returns both a net and a bus, since if the junction is processed first,
    # it'll be unknown which it is
    nbs = []
    for is_bus in False, True:
      ic = InstCoord(context, junction, is_bus)
      netbus = self._by_instcoord.getrep(ic, NetBus.new(is_bus))
      netbus.add_node(ic.instance, junction)
      nbs.append(netbus)
    return nbs

  def resolve(self):
    # Processes accumulated netlisting tasks. Call after adding everything.
    for bus in self._unresolved_buses:
      for il, netname, net in bus.gen_local_labels():
        net = self._by_instlabel.setrep(il, net)
        # A member net of a bus, where the bus is only named at a deeper level
        # of hierarchy should ignore the higher-level net label when determining
        # the net final name. For now, rather than delete, change the category.
        net.change_name_category(netname, NetBus.CAT_LABEL, NetBus.CAT_SHEETPIN)
    for bus in self._unresolved_buses:
      bus.resolve_sheetpins()
    self._unresolved_buses.clear()

  def generate_netmap(self, svg):
    # Returns a database of nets for the UI index
    # IDs are generated by using the svg's uid system
    # Map is organized for most compact storage
    # {
    #   "names": {
    #     netbus_id: name
    #   },
    #   "map": {
    #     instance: {
    #       netbus_id: [
    #         node_id,
    #         (symuuid, pinnumber),
    #         ... ],
    #       ...
    #     },
    #   },
    #   "bus": {
    #     parent_bus_id: [child_netbus_id, ... ],
    #   }
    # }
    assert not self._unresolved_buses
    netmap = {}
    names = {}
    busmap = {}
    for netbus in self._by_instcoord.values():
      netbus_id = svg.getuid(netbus)
      if not netbus.unmerged or netbus_id in names:
        continue
      name = netbus.name()
      if name is None:
        continue
      names[netbus_id] = netbus.name()
      for instance, node_id in netbus.nodes(svg):
        if instance is None:
          busmap.setdefault(node_id, []).append(netbus_id)
        else:
          netmap.setdefault(instance, {}).setdefault(netbus_id, []).append(
            node_id
          )
    return {
      "names": names,
      "map": netmap,
      "bus": busmap,
    }

  def generate_netlist(self, fmt):
    assert not self._unresolved_buses
    prefix = "$NETS\n" if fmt == Net.FMT_TELESIS else ""
    nets = {
      id(n): n
      for n in self._by_instcoord.values()
      if not n._mergedinto and isinstance(n, Net)
    }
    netlist = []
    for net in nets.values():
      formatted = net.fmt(fmt)
      if formatted:
        netlist.append(formatted)
    return prefix + "\n".join(sorted(netlist, key=lambda x: x.lstrip("'")))

  def __str__(self):
    return self.generate_netlist(Net.FMT_NAMES)
